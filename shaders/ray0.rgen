#version 460 core
#extension GL_EXT_ray_query : enable
#extension GL_EXT_buffer_reference : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : enable
#extension GL_EXT_ray_tracing : enable

#include "/lib/rt/payload.glsl"
#include "/lib/rt/sampling.glsl"
#include "/lib/rand.glsl"
#include "/lib/constants.glsl"
#include "/lib/settings.glsl"
#include "/lib/light_color.glsl"
#include "/lib/colors.glsl"

const float SPHERE_SOLID_ANGLE = 4.0 * PI;
const float SUN_SOLID_ANGLE = 6.794e-5;
const float MOON_SOLID_ANGLE = 6.418e-5;
const float SKY_INTENSITY = 0.8;
const float SUN_INTENSITY = 398110.0 * SUN_SOLID_ANGLE / SPHERE_SOLID_ANGLE;
const float MOON_INTENSITY = 1.0 * MOON_SOLID_ANGLE / SPHERE_SOLID_ANGLE;
const float EMISSION_INTENSITY = 0.55;
const vec3 WATER_ABSORPTION = (1.0 - vec3(0.28, 0.44, 0.86)) * 0.05;

layout(std140, binding = 0) uniform CameraInfo {
    vec3 corners[4];
    mat4 viewInverse;
    vec4 sunPosition;
    vec4 moonPosition;
    uint frameId;
    uint flags;
} cam;

layout(binding = 1) uniform accelerationStructureEXT acc;

layout(binding = 2) buffer BlasDataAddresses { 
    uint64_t address[]; 
} quadBlobs;

layout(binding = 3) writeonly uniform image2D outImage;
layout(binding = 4) uniform sampler2D blockTex;

layout(location = 6) rayPayloadEXT Payload payload;

float fresnel(float cosTheta, float F0) {
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

void main() {
    initRNG(uvec2(gl_LaunchIDEXT.xy), cam.frameId);
    vec2  px        = vec2(gl_LaunchIDEXT.xy) + vec2(0.5);
    vec2  p         = px / vec2(gl_LaunchSizeEXT.xy);
    vec3  origin    = cam.viewInverse[3].xyz;
    vec3  target    = mix(mix(cam.corners[0], cam.corners[2], p.y), mix(cam.corners[1], cam.corners[3], p.y), p.x);
    vec3  direction = (cam.viewInverse * vec4(normalize(target.xyz), 0.0)).xyz;
    uint  rayFlags  = gl_RayFlagsCullBackFacingTrianglesEXT;
    float tMin      = 0.0001;
    float tMax      = 4096.0;

    bool translucent = (cam.flags & 3u) == 1u;
    vec3 absorption = translucent ? WATER_ABSORPTION : vec3(0.0);

    vec3 sunDir = normalize(mat3(cam.viewInverse) * cam.sunPosition.xyz);
    vec3 moonDir = normalize(mat3(cam.viewInverse) * cam.moonPosition.xyz);

    vec3 throughput = vec3(1.0);
    vec3 radiance = vec3(0.0);
    for (int i = 0; i < RAY_BOUNCES; i++) {
        traceRayEXT(
            acc, // acceleration structure
            rayFlags, // rayFlags
            0xFF, // cullMask
            0, // sbtRecordOffset // <- see comment [1] below
            0, // sbtRecordStride // <- see comment [1] below
            0, // missIndex
            origin, //origin       // ray origin
            tMin, // ray min range
            direction, // ray direction
            tMax, // ray max range
            6// payload (location = 6)
        );
        Payload hitPayload = payload;

        float t = hitPayload.hitData.w;

        if (translucent) {
            throughput *= exp(-t * absorption);
        }

        if (t < 0.0) {
            radiance += throughput * getSkyColor(direction, sunDir) * SKY_INTENSITY;
            break;
        }

        radiance += throughput * hitPayload.color.rgb * hitPayload.emission * EMISSION_INTENSITY;
        origin = hitPayload.hitData.xyz;

        bool moon = (randFloat() * 0.2 - 0.1) > sunDir.y;
        vec3 lightDir = moon ? moonDir : sunDir;
        vec3 coneLightDir = mix(cosineWeightedHemisphereSample(lightDir), lightDir, 0.95);
        if (hitPayload.color.a == 1.0 && dot(hitPayload.geometryNormal, coneLightDir) > 0.0) {
            float cosTheta = dot(hitPayload.normal, coneLightDir);
            traceRayEXT(
                acc, // acceleration structure
                rayFlags, // rayFlags
                0xFF, // cullMask
                0, // sbtRecordOffset // <- see comment [1] below
                0, // sbtRecordStride // <- see comment [1] below
                0, // missIndex
                origin,       // ray origin
                tMin, // ray min range
                coneLightDir, // ray direction
                tMax, // ray max range
                6// payload (location = 6)
            );
            if (payload.hitData.w < 0.0) {
                vec3 light = moon ? vec3(0.1) * MOON_INTENSITY : getSunColor(sunDir) * SUN_INTENSITY;
                radiance += hitPayload.color.rgb * throughput * cosTheta * light / PI;
            }
        }

        if (hitPayload.color.a < 1.0) {
            vec3 normal = hitPayload.normal;
            if (dot(normal, direction) > 0.0) {
                normal = -normal;
            }
            float fres = fresnel(dot(-direction, normal), 0.02);

            if (randFloat() < fres) {
                direction = reflect(direction, normal);
            } else {
                vec3 newDirection = refract(direction, normal, translucent ? 1.3333 : 1.0 / 1.3333);
                if (dot(newDirection, newDirection) < 0.01) {
                    throughput /= fres;
                    newDirection = reflect(direction, normal);
                    translucent = false;
                } else {
                    throughput /= 1.0 - fres;
                }
                direction = newDirection;
                if (translucent) {
                    absorption = vec3(0.0);
                } else {
                    absorption = WATER_ABSORPTION;
                    translucent = true;
                }
            }
        } else {
            direction = cosineWeightedHemisphereSample(hitPayload.normal);
            if (dot(direction, hitPayload.geometryNormal) <= 0.0) {
                direction = -direction;
            }
            throughput *= hitPayload.color.rgb;
        }

        float throughputLuma = luminance(throughput);
        if (randFloat() > throughputLuma) {
            break;
        }
        throughput /= throughputLuma;
    }

    imageStore(outImage, ivec2(gl_LaunchIDEXT), vec4(radiance, 1.0));
}
